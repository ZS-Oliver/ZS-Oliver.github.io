<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[类型转换与集合转换]]></title>
    <url>%2F2019%2F01%2F03%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E9%9B%86%E5%90%88%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[类型转换parseInt()、valueOf()、toString()和intValue()的区别与联系 parseXxx():将String转换为对应xxx的普通数据类型String s = “123”;int b = Integer.parseInt(a);b就是int类型123了byte c = Byte.parseByte(a);c就是byte类型123了 valueOf():将参数转换为对应的包装类型String a = “123”;Integer b = Integer.valueOf(a);此时b为Integer类型 intValue():将Integer类型转换为int类型Integer a = 1;int b = a.intValue(a);此时b为int类型 toString():将引用数据类型转换为String字符串类型Integer a = new Integer(123);String b = a.toString();此时b为“123” 基本类型的数组转换为包装类型的数组 12345678910111213// java8实现方法int[] arr = &#123;&#125;;List&lt;Integer&gt; list = Arrays.stream(arr).boxed().collect(Collectors.toList());// apache commons-lang3 jar// maven&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt;&lt;/dependency&gt;Integer[] list = ArrayUtils.toObject(arr); 集合转换 数组转list1234567// 要求要转换的数组必须类型一致Integer[] arr = &#123;&#125;;// 第一种List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(arr));// 第二种List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.addAll(Arrays.asList(arr)); 12345// 相对于上一种方法速度更快// 要求要转化的数组必须类型一致Integer[] arr = &#123;&#125;;List&lt;Integer&gt; list = new ArrayList&lt;&gt;();Collections.addAll(list,arr); list转数组123// 只能得到对应包装类型的数组List&lt;Integer&gt; list = new ArrayList&lt;&gt;();Integer[] arr = list.toArray(new Integer[list.size]);]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令整理]]></title>
    <url>%2F2018%2F12%2F12%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[用户操作 新建用户(以下命令必须在root权限下使用)123456// 新建用户后,用户信息会保存在/home和/etc/passwd下useradd visitor // 新建用户，用户名为visitorpasswd visitor // 为新建用户设置密码userdel visitor // 删除用户visitorrm -rf visitor // 删除用户visitor所在目录 新建用户组 1234groupadd visitgroup // 添加用户组groupdel visitgroup // 删除用户组gpasswd -a visitor visitgroup // 把用户visitor添加到visitgroup组中(加入组后,visitor获得visitgroup组所有权限)gpasswd -d visitor visitgroup // 把用户visitor移出visitgroup组 切换用户 1su // su是switch user的缩写,exit即退回到刚才的用户状态 切换目录 12345cd xx // 切换到该目录下的xx目录cd .. // 切换到上一层目录cd / // 切换到系统根目录cd ~ // 切换到用户主目录cd - // 切换到上一个所在目录 目录操作(增删查改) 1234567mkdir xx // 增加名为xx的目录ls或者ll // 查看目录详细信息find /home -name &quot;*.txt&quot; // 查找/home目录下以.txt结尾的文件。(-iname忽略大小写)mv 目录名称 新目录名称 // 修改目录的名称mv 目录名称 目录的新位置 // 移动目录的位置cp -r 目录名称 目录拷贝的目标位置 // 拷贝目录rm -rf 目录/文件/压缩包 // 删除操作 文件操作(增删查改) 123456789101112touch 文件名称 // 文件的创建cat/more/less/tail 文件名称 // 文件的查看 cat:只能显示最后一屏内容 more:显示百分比，回车向下一行,空格向下一页，q退出查看 less:使用键盘上的PgUp和PgDn向上向下翻页，q结束查看 tail-10:查看文件的后10行，Ctrl+C结束(注)tail -f 文件 // 可以对某个文件进行动态监控vim 文件 // 修改文件的内容 i // 进入编辑模式 Esc // 进入底行模式,输入:wq/q! (输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存) 输入./进入文件搜索，输入要搜索的单词，回车，即可跳转到该单词所在的位置。rm -rf 文件 // 删除文件 压缩操作 1234567tar -zcvf 打包压缩后的文件名 要打包压缩的文件 // 打包并压缩文件,压缩后的文件以 .tar.gz结尾 z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名tar -xvf 压缩文件 // 解压压缩包 x：代表解压 其他操作 1234567891011pwd // 显示当前所在位置grep 要搜索的字符串 要搜索的文件 --color // 搜索命令，--color代表高亮显示shutdown -r now // 立即重启服务器wc // 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 命令格式：wc [选项]文件... 命令参数： -c 统计字节数。 -l 统计行数。 -m 统计字符数。这个标志不能与 -c标志一起使用。 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。 -L 打印最长行的长度]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收机制详解]]></title>
    <url>%2F2018%2F12%2F08%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[垃圾收集概念GC需要做三件事： 分配内存，为每个新建的对象分配空间 确保还在使用的对象的内存一直都在，不能把有用的空间当垃圾回收了 释放不再使用的对象所占用的内存 GC Roots把还被GC Roots引用的对象称为活的，把不再被引用的对象认为死的。 GC Roots有： 当前各线程执行方法中的局部变量(包括形参)引用的对象 已被加载的类的static域引用的对象 方法去中常量引用的对象 JNI(Java Native Interface)引用 性能指标 吞吐量：应用程序的执行时间占总时间的百分比，越高越好 垃圾收集开销：垃圾收集时间占总时间的百分比 停顿时间：垃圾收集过程中导致的应用挂起时间 频次：相对于应用程序来说，垃圾收集的频次 空间：垃圾收集占用的内存 及时性：一个对象从成为垃圾到该对象空间再次可用的时间 垃圾回收类型内存被组织分成三个年代：年轻代、老年代、永久代；大部分对象初始化都是在年轻代中，老年代存放经过几次年轻代垃圾收集还活着的对象，还有部分大对象因为比较大所以直接分配在老年代，永久代通常也叫方法区，用于存储已加载类的元数据，以及存储运行时常量池等。 当年轻代被填满后，会进行一次年轻代垃圾收集(minor GC) 当老年代或永久代被填满了，会触发full GC(major GC)，full GC 会收集所有区域，先进行年轻代的收集，使用年轻代专用的垃圾回收算法，然后使用老年代的垃圾回收算法回收老年代和永久代。如果算法带有压缩，每个代分别独立的进行压缩。 分配内存 如果垃圾收集完成后，存在大片连续的内存可用于分配给新对象，此时使用指针碰撞分配对象空间(检测是否有足够的空间，如果有，指针往前移动你N位就分配好空间了) 对于多线程应用，对象分配必须要保证线程安全性，如果使用全局锁，那么分配空间将成为瓶颈并降低程序性能。HotSpot使用TLABs，给与每个线程一部分内存作为缓冲区，每个线程都在自己的缓存区种进行指针碰撞，这样就不用获取全局锁了。 串行收集器串行收集器，年轻代和老年代都使用单线程进行收集，收集过程中会 stop-the-world。所以当在垃圾收集的时候，应用程序是完全停止的。在年轻代和老年代中都使用串行收集器，年轻代中使用 stop-the-world、复制 算法；老年代使用 stop-the-world、标记 -&gt; 清理 -&gt; 压缩 算法 并行收集器并行收集器，即吞吐量收集器，利用多核的优势来进行垃圾收集，而不是像串行收集器一样将程序挂起后只使用单线程来收集垃圾。在年轻代中使用 并行、stop-the-world、复制 算法；老年代使用串行收集器的 串行、stop-the-world、标记 -&gt; 清理 -&gt; 压缩 算法 并行压缩收集器在年轻代中使用并行收集器的 并行、stop-the-world、复制 算法；老年代使用 并行、stop-the-world、标记 -&gt; 清理 -&gt; 压缩 算法。和并行收集器的区别是老年代使用了并行 CMS收集器(低延时收集器) 在年轻代中，CMS和并行收集器一样，即：并行、stop-the-world、复制 在老年代中，大部分收集任务是和应用程序并发执行的 CMS 收集过程首先是一段小停顿 stop-the-world，叫做 初始标记阶段（initial mark），用于确定 GC Roots。然后是 并发标记阶段（concurrent mark），标记 GC Roots 可达的所有存活对象，由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。为了解决这个问题，需要再次停顿应用程序，称为 再次标记阶段（remark），遍历在并发标记阶段应用程序修改的对象（标记出应用程序在这个期间的活对象），由于这次停顿比初始标记要长得多，所以会使用多线程并行执行来增加效率。再次标记阶段结束后，能保证所有存活对象都被标记完成，所以接下来的 并发清理阶段（concurrent sweep） 将就地回收垃圾对象所占空间。 CMS是唯一不进行压缩的收集器，在它释放了垃圾对象占用的空间后，不会移动存活对象到一边去。着将节省垃圾回收的时间。 缺点 由于之后空闲空间不是连续的，所以也就不能使用简单的 指针碰撞（bump-the-pointer） 进行对象空间分配了。它需要维护一个 空闲列表，将所有的空闲区域连接起来，当分配空间时，需要寻找到一个可以容纳该对象的区域。 CMS 收集器相比其他收集器需要使用更大的堆内存。因为在并发标记阶段，程序还需要执行，所以需要留足够的空间给应用程序。 虽然收集器能保证在标记阶段识别出所有的存活对象，但是由于应用程序并发运行，所以刚刚标记的存活对象很可能立马成为垃圾，而且这部分由于已经被标记为存活对象，所以只能到下次老年代收集才会被清理，这部分垃圾称为 浮动垃圾。 由于缺少压缩环节，堆将会出现碎片化问题。为了解决这个问题，CMS 收集器需要追踪统计最常用的对象大小，评估将来的分配需求，可能还需要分割或合并空闲区域。 G1垃圾收集器 G1的主要关注点在于达到可控的停顿时间，在这个基础上尽可能的提高吞吐量。 G1被设计用来长期取待CMS收集器，和CMS相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。 当应用使用了较大的堆并且还要求有较低的垃圾收集停顿时间，选择G1。 内存划分G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。 收集流程G1收集器包含以下4各操作，年轻代收集、并发收集，和应用线程同时执行、混合式垃圾收集、必要时的 Full GC 年轻代收集(Young GC) G1收集器将堆内存分为大小固定的区块，整堆分为约2000块，每块大小是一致的 逻辑上，也会分为Eden、Survivor、Old区，但是各个区的大小不是固定的，未分配区可以用于任何一代 年轻代由几个不连续的区块组成，这样需要的时候可以很容易扩容、缩容 Young GC是并行、stop-the-world的 将活着的对象复制到Survivor区，或晋升到Old区 为了下一次Young GC，需要调整Eden区和Survivor区的大小 Old GC/并发标记周期 初始标记：stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用。 扫描根引用区：扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束。 并发标记：寻找整个堆的存活对象，该阶段可以被 Young GC 中断。 重新标记：stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法。 清理：清理阶段真正回收的内存很少。 混合垃圾回收周期 并发周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。 混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。 Full GC concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记。(这个时候说明堆需要增加了，或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束或者就是更早地进行并发周期，默认是整堆内存的 45% 被占用就开始进行并发周期) 晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败。(说明混合垃圾回收需要更迅速完成垃圾收集，也就是说在混合回收阶段，每次年轻代的收集应该处理更多的老年代已标记区块。) 疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的。(最简单的就是增加堆大小) 大对象分配失败:我们应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象。G1 参数配置和最佳实践 G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间。有以下几点我们可以进行调整的方向： 增加堆大小，或调整老年代和年轻代的比例，这个很好理解 增加并发周期的线程数量，其实就是为了加快并发周期快点结束 让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%） 在混合垃圾回收周期中回收更多的老年代区块 G1对比CMS优点 G1是一个有整理内存过程的垃圾收集器，不会产生过多内存碎片。CMS采用标记清除垃圾回收算法，可能会产生不少内存碎片。 G1的 Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。 共同点 他们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用操作及常见问题解决]]></title>
    <url>%2F2018%2F12%2F07%2FGit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[与远程仓库建立连接 在远程仓库新建一个项目 生成本地的git管理,在terminal或git里输入 git init 将项目中所有文件添加到仓库中 git add . 添加对本次提交的注释 git commit -m “” (双引号内为对于本次提交的注释内容) 将本地的仓库关联到远程仓库 git remote add origin https://github.com/ZS-Oliver/go.git 将代码上传到远程仓库 git push -u origin master(-u操作,Git不但会把本地的master分支内容推送到远程新的master分支,还会把本地的master分支和远程的master分支关联起来,在以后的推送或者拉取时就可以简化命令) 分支问题 查看分支信息 1git branch 在本地新建一个分支 1git branch newBranchName 切换分支 1git checkout branch 在本地创建并切换到新分支 1git checkout -b newBranchName 将新分支发布到远程仓库 1git push origin newBranchName 在本地删除一个分支 1git branch -d newBranchName 删除远程仓库的一个分支 1git push origin :newBranchName/git push origin -delete newBranchName // 删除远程分支后,对应的本地分支并不会同步删除 合并指定分支到当前分支 1git merge branchName stash 把本地修改且未提交的内容,存储到本地栈的栈顶 1git stash 把保存在本地栈的代码pop到本地 1git stash pop stash的同时,存储一个log日志 1git stash save &quot;&quot; //双引号为日志内容 查看本地存储的stash日志 1git stash list stash多个日志时,有选择的pop 1git stash apply stash@&#123;&#125; //@&#123;&#125;为对应日志序号 清空暂存栈 1git stash clear 回退 撤销一次提交 1git revert 回退到上一个版本 12git reset --hard HEAD^ // 回退到上一版本，(Git中, **HEAD** 表示当前版本,也就是最新的提交,HEAD^ 为上一个版本,HEAD^^为上上个版本,也可以用**HEAD~3**表示)git reset --hard 版本号 // 回退到指定版本(版本号只需要写前几位) 将暂存区的修改撤销掉,重新放回工作区 1git reset HEAD &lt;file&gt; // 使用git rm删除文件后,复原操作,需要先git reset HEAD &lt;file&gt;,然后再git checkout -- &lt;file&gt; 将工作区的修改全部撤销 1git checkout -- file // file为要撤销的文件 撤销上一次的合并分支 1git merge --abort 其他 查看日志 1git log 查看暂存区状态 1git status 查看之前的所有命令日志 1git reflog 删除文件 12rm file // 删除本地文件git rm file // 从版本库中删除文件 问题原因及解决方法 问题: Another git process semms to be running in this repository, e.g. an editor opened by ‘git commit’. Please make sure all processes are terminated then try again. If it still fails, a git process remove the file manually to continue… 原因: git被另外一个程序占用，重启机器也不能够解决。Git在使用过程中遭遇了奔溃，部分被上锁资源没有被释放导致的。 解决方法: 进入项目文件夹下的 .git文件中（显示隐藏文件夹或rm .git/index.lock）删除index.lock文件即可。 问题: There is no tracking information for the current branch.Please specify which branch you want to merge with. 原因: 本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系) 解决方法: 1git branch --set-upstream-to=origin/远程分支的名字 本地分支的名字 问题: 使用git pull提示refusing to merge unrelated histories 原因: 远程仓库origin上的分支master和本地分支master被Git认为是不同的仓库，所以不能直接合并。 解决方法:12git pull --allow-unrelated-histories解决冲突后再执行 git push 问题: hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. ‘git pull’)hint: before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 原因: 远程repository和本地的repository冲突 解决方法: 新建分支,切换到新分支,pull,然后切换到主分支,合并分支,解决冲突 问题：fatal:remote origin already exists 解决方法：1234删除远程Git仓库git remote rm origin添加远程Git仓库git remote add origin...]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[240 搜索二维矩阵II]]></title>
    <url>%2F2018%2F02%2F02%2F240%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II%2F</url>
    <content type="text"><![CDATA[m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：每行的元素从左到右升序排列。每列的元素从上到下升序排列。示例：12345678910111213现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。 代码实现：1234567891011121314151617public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int j = matrix[0].length - 1; int i = 0; while (i &lt; matrix.length &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] == target) &#123; return true; &#125; else if (matrix[i][j] &gt; target) &#123; j--; &#125; else &#123; i++; &#125; &#125; return false; &#125; 思路：1将target与每行的最后一个值比较，若target大于最后一个值，则target在改行下面，直到target小于等于最后一个值，此时target要么在该行，要么不存在]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[169 求众数]]></title>
    <url>%2F2018%2F02%2F02%2F169%20%E6%B1%82%E4%BC%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。123说明：你可以假设数组是非空的，并且给定的数组总是存在众数。 示例1：12输入: [3,2,3]输出: 3 示例2：12输入: [2,2,1,1,1,2,2]输出: 2 代码实现：123456789101112131415161718public int majorityElement(int[] nums) &#123; int count = 0; int res = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (count == 0) &#123; res = nums[i]; count++; &#125; else &#123; if (nums[i] == res) &#123; count++; &#125; else &#123; count--; &#125; &#125; &#125; return res; &#125; 思路：1众数的个数超过总个数的一半，因此，每次遇到不相同的数字，则相互抵消，遍历整个数组后，最后剩下的，一定是众数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[136 只出现一次的数字]]></title>
    <url>%2F2018%2F02%2F01%2F136%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。123说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例1：12输入: [2,2,1]输出: 1 示例2：12输入: [4,1,2,1,2]输出: 4 代码实现：12345678910public int singleNumber(int[] nums) &#123; if (nums.length == 0) &#123; return -1; &#125; int single = 0; for (int i = 0; i &lt; nums.length; i++) &#123; single ^= nums[i]; &#125; return single; &#125; 思路：123异或运算(^) 参与运算的两个对象，相应位相同为0，不同为1数组依次做异或运算，相同值抵消，便得到最终结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
