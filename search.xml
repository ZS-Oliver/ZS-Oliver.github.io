<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[整理Java Enum类相关知识]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%95%B4%E7%90%86Java%20Enum%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[定义 将相关常量分组到一个枚举类型 123456789101112public enum Sex&#123; MALE,FEMALE&#125;public enum Sex&#123; MALE(1),FEMALE(2); // 通过构造方法传参 private int code; private Sex(int code)&#123; this.code = code; &#125;&#125; 在枚举类中添加方法,需在enum实例序列的最后加分号,且java要先定义enum实例 123456789101112131415161718public enum Sex&#123; // enum实例序列 MALE(&quot;雄性&quot;,1),FEMALE(&quot;雌性&quot;,2); // 成员变量 private String name; private int index; // 构造方法 private Sex(String name,int index)&#123; this.name = name; this.index = index; &#125; // 普通方法 public static final Map&lt;String,int&gt; kv = Arrays.stream(values()).collect(Collectors.toMap(Sex::getName,Sex::getIndex));&#125; 常用方法12345枚举类.values() // 返回包括所有枚举变量的数组枚举变量.oridal() // 枚举类会给所有的枚举变量一个默认的次序,从0开始 .ordinal()方法就是获取这个次序枚举变量.toString() // 直接返回枚举定义枚举变量的字符串枚举变量.toString() // 返回该枚举变量所对应的字符串枚举变量.compareTo() // 比较两个枚举变量的次序,返回两个次序相减后的结果 枚举集合 java.util.EnumSet和java.util.EnumMap是两个枚举集合,EnumSet保证集合中元素不重复,EnumMap中的key是enum类型,value是任意类型 EnumSet (注)EnumSet里的枚举变量必须属于同一个枚举值 1234// 创建包含指定枚举类型中所有枚举变量的EnumSetEnumSet&lt;E&gt; es = EnumSet.allOf(E.class);// EnumSet为非同步的,创建同步EnumSetSet&lt;E&gt; s = Collections.synchronizedSet(EnumSet.noneOf(E.class)); EnumMap 123456// EnumMap实例化,E为枚举类类型EnumMap&lt;E,String&gt; enumMap = new EnumMap&lt;&gt;(E.class);// 通过put()方法,给对应的枚举变量赋value值enumMap.put(E.xx,str);// 通过get()方法,根据传入的枚举变量获得对应的value值String str = enumMap.get(E.xx); 其他知识点 枚举类继承自java.lang.Enum类,所以枚举对象不能再继承其他类。被enum修饰的类默认为final,所以也不能被其他类继承。 enum类可以实现接口,在interface内部定义enum块,即可通过继承接口,达到组合enum与元素的目的。 enum类中的元素定义必须写在所有其他部分前面,否则会编译错误。 values()方法是编译器插入到enum定义中的static方法,所以,当你将enum实例向上转型为父类Enum时,values()就不可访问了。解决办法:在Class中有一个getEnumConstants()方法，所以即便Enum接口中没有values()方法,我们仍然可以通过Class对象取得所有的enum实例]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[328 奇偶链表]]></title>
    <url>%2F2019%2F03%2F12%2F237%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。示例1：123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例2：123输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明：1234链表至少包含两个节点。链表中所有节点的值都是唯一的。给定的节点为非末尾节点并且一定是链表中的一个有效节点。不要从你的函数中返回任何结果。 代码实现：1234public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125; 思路：1将下一个节点复制到当前节点]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[328 奇偶链表]]></title>
    <url>%2F2019%2F03%2F12%2F328%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例1：12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例2：12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明：12应当保持奇数节点和偶数节点的相对顺序。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 代码实现：12345678910111213141516171819public ListNode oddEvenList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode pre = head; ListNode cur = head.next; ListNode tmp = null; while (cur != null &amp;&amp; cur.next != null) &#123; tmp = pre.next; pre.next = cur.next; cur.next = cur.next.next; pre.next.next = tmp; pre = pre.next; cur = cur.next; &#125; return head; &#125; 思路：1234使用两个指针，pre指向奇节点，cur指向偶节点。把偶节点cur后面的那个奇节点提前到pre的后面。然后pre和cur各自前进一步，此时cur又指向偶节点，pre指向当前奇节点的末尾。重复]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[141 环形链表]]></title>
    <url>%2F2019%2F03%2F06%2F141%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例1：123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例2：123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例3：123输入：head = [1], pos = -1输出：false解释：链表中没有环。 代码实现：123456789101112131415public boolean hasCycle(ListNode head) &#123; if(head == null || head.next == null)&#123; return false; &#125; ListNode fast = head; ListNode slow = head; while(fast != null &amp;&amp; fast.next != null)&#123; fast = fast.next.next; slow = slow.next; if(fast == slow)&#123; return true; &#125; &#125; return false; &#125; 思路：1快慢指针，当两者相等时，则有环]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[138 复制带随机指针的链表]]></title>
    <url>%2F2019%2F03%2F06%2F138%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深拷贝。 示例：123456输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;解释：节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。 提示：1你必须返回给定头的拷贝作为对克隆列表的引用。 代码实现：123456789101112131415161718192021public Node copyRandomList(Node head) &#123; if (head == null) &#123; return null; &#125; HashMap&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Node temp = head; while (temp != null) &#123; map.put(temp, new Node(temp.val, temp.next, temp.random)); temp = temp.next; &#125; temp = head; while (temp != null) &#123; map.get(temp).next = map.get(temp.next); map.get(temp).random = map.get(temp.random); temp = temp.next; &#125; return map.get(head); &#125; 思路：123用一个hash表维护一个关系key为当前节点，value为当前节点的next和random通过遍历hash表来重新构造链表]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[150 逆波兰表达式求值]]></title>
    <url>%2F2019%2F03%2F06%2F150%20%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%2F</url>
    <content type="text"><![CDATA[根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明：12整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例1：123输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9 示例2：123输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6 示例3：12345678910输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 代码实现：123456789101112131415161718192021222324String signal = &quot;+-*/&quot;; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; nums = new Stack&lt;&gt;(); for (int i = 0; i &lt; tokens.length; i++) &#123; if (signal.contains(tokens[i])) &#123; int second = nums.pop(); int first = nums.pop(); if (&quot;+&quot;.equals(tokens[i])) &#123; first = first + second; &#125; else if (&quot;-&quot;.equals(tokens[i])) &#123; first = first - second; &#125; else if (&quot;*&quot;.equals(tokens[i])) &#123; first = first * second; &#125; else &#123; first = first / second; &#125; nums.push(first); &#125; else &#123; nums.push(Integer.parseInt(tokens[i])); &#125; &#125; return nums.pop(); &#125; 思路：1维护一个栈，当是数字的时候，直接push，当是符号的时候，从栈顶pop两个元素做运算]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[239 滑动窗口最大值]]></title>
    <url>%2F2019%2F03%2F06%2F239%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。返回滑动窗口最大值示例：123456789101112输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 注意：1你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。 代码实现：12345678910111213141516171819202122232425262728293031public int[] maxSlidingWindow(int[] nums, int k) &#123; int[] res = new int[nums.length - k + 1]; int count = 0; if (nums.length == 0 || nums == null) &#123; return nums; &#125; LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; k - 1; i++) &#123; while (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.getLast()]) &#123; queue.removeLast(); &#125; queue.addLast(i); &#125; for (int i = k - 1; i &lt; nums.length; i++) &#123; while (!queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.getLast()]) &#123; queue.removeLast(); &#125; queue.addLast(i); if (i - queue.getFirst() + 1 &gt; k) &#123; queue.removeFirst(); &#125; res[count++] = nums[queue.getFirst()]; &#125; return res; &#125; 思路：123456789使用一个双向队列，记录元素的索引。保证队列头是当前最大的元素插入元素，判断当前元素是否前面的元素，如果大于，则删除前面的元素如果小于，则直接插入1. 初始化，遍历比窗口小一的大小，按照上述规则插入2. 继续按照上述规则插入，插入后，判断队列大小是否超出容器大小，超出，则删除头部。3. 当前头部就是最大的元素索引]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[347 前K个高频元素]]></title>
    <url>%2F2019%2F03%2F06%2F347%20%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[给定一个非空的整数数组，返回其中出现频率前 k 高的元素。示例1：12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例2：12输入: nums = [1], k = 1输出: [1] 说明：12你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 代码实现：1234567891011121314151617181920212223public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (!map.containsKey(nums[i])) &#123; map.put(nums[i], 1); &#125; else &#123; map.put(nums[i], map.get(nums[i]) + 1); &#125; &#125; PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; heap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2.getValue() - o1.getValue()); for (Map.Entry&lt;Integer, Integer&gt; m : map.entrySet()) &#123; heap.offer(m); &#125; for (int i = 0; i &lt; k; i++) &#123; res.add(heap.poll().getKey()); &#125; return res; &#125; 思路：123使用HashMap统计每个key出现的次数重写堆的排序规则，按次数排序取前k个元素]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[378 有序矩阵中第K小的元素]]></title>
    <url>%2F2019%2F03%2F06%2F378%20%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。请注意，它是排序后的第k小元素，而不是第k个元素。示例：12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,返回 13。 说明：1你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n2 。 代码实现：1234567891011121314151617181920public int kthSmallest(int[][] matrix, int k) &#123; if (k &lt; 0 || k &gt; matrix.length * matrix[0].length) &#123; return -1; &#125; PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder()); for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; if (maxHeap.size() &lt; k) &#123; maxHeap.offer(matrix[i][j]); &#125; else &#123; if (maxHeap.peek() &gt; matrix[i][j]) &#123; maxHeap.poll(); maxHeap.offer(matrix[i][j]); &#125; &#125; &#125; &#125; return maxHeap.peek(); &#125; 思路：1维护一个最大堆，大小为k，即maxHeap.poll()为第k小的元素]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[295 数据流的中位数]]></title>
    <url>%2F2019%2F03%2F06%2F295%20%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。例如 [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例：12345addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 代码实现：123456789101112131415161718192021222324252627int count = 0; PriorityQueue&lt;Integer&gt; minHeap = null; PriorityQueue&lt;Integer&gt; maxHeap = null; /** initialize your data structure here. */ public MedianFinder() &#123; minHeap = new PriorityQueue&lt;&gt;(); maxHeap = new PriorityQueue&lt;&gt;(Comparator.reverseOrder()); &#125; public void addNum(int num) &#123; if (count % 2 == 0) &#123; maxHeap.offer(num); minHeap.offer(maxHeap.poll()); &#125; else &#123; minHeap.offer(num); maxHeap.offer(minHeap.poll()); &#125; count++; &#125; public double findMedian() &#123; if (count % 2 == 1) &#123; return minHeap.peek(); &#125; else &#123; return (maxHeap.peek() + minHeap.peek()) / 2.0; &#125; &#125; 思路：123同时维护最大堆和最小堆保证最大堆中存储的是数组中小的部分，且头部是中间值保证最小堆中存储的是数组中大的部分，且头部是中间值]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[215 数组中的第K个最大元素]]></title>
    <url>%2F2019%2F03%2F06%2F215%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。示例1：12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例2：12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明：1你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 代码实现：12345678910111213public int findKthLargest(int[] nums, int k) &#123; if (nums.length == 0 || k &lt; 0 || k &gt; nums.length) &#123; return -1; &#125; PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(); for (int val : nums) &#123; heap.offer(val); if (heap.size() &gt; k) &#123; heap.poll(); &#125; &#125; return heap.peek(); &#125; 思路：1PriorityQueue 时间复杂度为 Nlog(K),空间复杂度为K]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[155 最小栈]]></title>
    <url>%2F2019%2F03%2F05%2F155%20%E6%9C%80%E5%B0%8F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例：12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 代码实现：1234567891011121314151617181920212223242526272829Stack&lt;Integer&gt; stack; Stack&lt;Integer&gt; minStack; public MinStack() &#123; this.stack = new Stack&lt;&gt;(); this.minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if (minStack.empty() || minStack.peek() &gt;= x) &#123; minStack.push(x); &#125; &#125; public void pop() &#123; int x = stack.pop(); if (minStack.peek() == x) &#123; minStack.pop(); &#125; &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125; 思路：1维护两个栈，一个保存所有值，一个只保存当前最小值]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[212 单词搜索II]]></title>
    <url>%2F2019%2F03%2F05%2F212%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II%2F</url>
    <content type="text"><![CDATA[给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。 示例：12345678910输入: words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]输出: [&quot;eat&quot;,&quot;oath&quot;] 说明：1你可以假设所有输入都由小写字母 a-z 组成。 提示：1234你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。 实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899方法一： static int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; static boolean[][] mark = null; public static List&lt;String&gt; findWords(char[][] board, String[] words) &#123; Set&lt;String&gt; res = new HashSet&lt;&gt;(); for (int i = 0; i &lt; words.length; i++) &#123; mark = new boolean[board.length][board[0].length]; for (int j = 0; j &lt; board.length; j++) &#123; for (int k = 0; k &lt; board[0].length; k++) &#123; if (board[j][k] == words[i].charAt(0)) &#123; mark[j][k] = true; if (exist(board, words[i], 1, j, k)) &#123; res.add(words[i]); break; &#125; mark[j][k] = false; &#125; &#125; &#125; &#125; List&lt;String&gt; result = new ArrayList&lt;&gt;(res); Collections.sort(result); return result; &#125; private static boolean exist(char[][] board, String words, int index, int j, int k) &#123; if (index == words.length()) &#123; return true; &#125; for (int i = 0; i &lt; directions.length; i++) &#123; int newJ = j + directions[i][0]; int newK = k + directions[i][1]; if (newJ &gt;= 0 &amp;&amp; newJ &lt; board.length &amp;&amp; newK &gt;= 0 &amp;&amp; newK &lt; board[0].length) &#123; if (!mark[newJ][newK] &amp;&amp; words.charAt(index) == board[newJ][newK]) &#123; mark[newJ][newK] = true; if (exist(board, words, index + 1, newJ, newK)) &#123; return true; &#125; mark[newJ][newK] = false; &#125; &#125; &#125; return false; &#125; 方法二： int[][] direction = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; class Trie &#123; Trie[] children = new Trie[26]; String word; &#125; boolean[][] vis; List&lt;String&gt; res; public List&lt;String&gt; findWord(char[][] board, String[] words) &#123; Trie root = new Trie(); for (String word : words) &#123; Trie cur = root; for (char c : word.toCharArray()) &#123; if (cur.children[c - &apos;a&apos;] == null) &#123; cur.children[c - &apos;a&apos;] = new Trie(); &#125; cur = cur.children[c - &apos;a&apos;]; &#125; cur.word = word; &#125; res = new ArrayList&lt;&gt;(); vis = new boolean[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; dfs(board, root, i, j); &#125; &#125; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(res); res.clear(); res.addAll(set); return res; &#125; private void dfs(char[][] board, Trie root, int x, int y) &#123; if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; board.length &amp;&amp; y &lt; board[0].length &amp;&amp; !vis[x][y]) &#123; vis[x][y] = true; root = root.children[board[x][y] - &apos;a&apos;]; if (root != null) &#123; if (root.word != null) &#123; res.add(root.word); &#125; for (int i = 0; i &lt; direction.length; i++) &#123; dfs(board, root, x + direction[i][0], y + direction[i][1]); &#125; &#125; vis[x][y] = false; &#125; &#125; 思路：12方法一使用DFS方法二使用DFS加Trie树，早点停止回溯]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[79 单词搜索]]></title>
    <url>%2F2019%2F03%2F05%2F79%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例；12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true.给定 word = &quot;SEE&quot;, 返回 true.给定 word = &quot;ABCB&quot;, 返回 false. 代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; int[][] directions = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;; boolean[][] mark = null; public boolean exist(char[][] board, String word) &#123; if (word == null || board.length == 0) &#123; return false; &#125; mark = new boolean[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (board[i][j] == word.charAt(0)) &#123; mark[i][j] = true; if (exist(board, word, 1, i, j)) &#123; return true; &#125; mark[i][j] = false; &#125; &#125; &#125; return false; &#125; private boolean exist(char[][] board, String word, int index, int i, int j) &#123; if (word.length() == index) &#123; return true; &#125; for (int temp = 0; temp &lt; directions.length; temp++) &#123; int newI = i + directions[temp][0]; int newJ = j + directions[temp][1]; if (newI &gt;= 0 &amp;&amp; newI &lt; board.length &amp;&amp; newJ &gt;= 0 &amp;&amp; newJ &lt; board[0].length) &#123; if (!mark[newI][newJ] &amp;&amp; word.charAt(index) == board[newI][newJ]) &#123; mark[newI][newJ] = true; if (exist(board, word, index + 1, newI, newJ)) &#123; return true; &#125; mark[newI][newJ] = false; &#125; &#125; &#125; return false; &#125;&#125; 思路：123深搜用一个二维数组表示上下左右四个方向另一个二维数组表示是否访问过该字母]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[208 实现Trie(前缀树)]]></title>
    <url>%2F2019%2F03%2F05%2F208%20%E5%AE%9E%E7%8E%B0Trie(%E5%89%8D%E7%BC%80%E6%A0%91)%2F</url>
    <content type="text"><![CDATA[实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。示例：12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 truetrie.search(&quot;app&quot;); // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true 说明：12你可以假设所有的输入都是由小写字母 a-z 构成的。保证所有输入均为非空字符串。 代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Trie &#123; class TrieNode &#123; boolean isEnd; char val; TrieNode[] children = new TrieNode[26]; TrieNode(char c) &#123; this.val = c; isEnd = false; &#125; &#125; private TrieNode root; /** Initialize your data structure here. */ public Trie() &#123; this.root = new TrieNode(&apos; &apos;); &#125; /** Inserts a word into the trie. */ public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; int n = word.charAt(i) - &apos;a&apos;; if (node.children[n] == null) &#123; node.children[n] = new TrieNode(word.charAt(i)); &#125; node = node.children[n]; &#125; node.isEnd = true; &#125; /** Returns if the word is in the trie. */ public boolean search(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; int n = word.charAt(i) - &apos;a&apos;; node = node.children[n]; if (node == null) &#123; return false; &#125; &#125; return node.isEnd; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) &#123; TrieNode node = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; int n = prefix.charAt(i) - &apos;a&apos;; node = node.children[n]; if (node == null) &#123; return false; &#125; &#125; return true; &#125;&#125; 思路：12345Trie树,是一种树形结构,是一种哈希树的变种,最大限度地减少无谓的字符串比较，查询效率比哈希表高通过isEnd 记录是否到达叶子节点val 记录具体的值children[] 封装isEnd和val]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[242 有效的字母异位词]]></title>
    <url>%2F2019%2F03%2F05%2F242%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。示例1：12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例2：12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 说明：1你可以假设字符串只包含小写字母。 代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152方法一：public boolean isAnagram(String s, String t) &#123; if (s == null &amp;&amp; t == null) &#123; return true; &#125; if (s == null || t == null) &#123; return false; &#125; Map&lt;Character, Integer&gt; mapS = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; mapT = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; if (mapS.containsKey(s.charAt(i))) &#123; mapS.put(s.charAt(i), mapS.get(s.charAt(i)) + 1); &#125; else &#123; mapS.put(s.charAt(i), 1); &#125; &#125; for (int i = 0; i &lt; t.length(); i++) &#123; if (mapT.containsKey(t.charAt(i))) &#123; mapT.put(t.charAt(i), mapT.get(t.charAt(i)) + 1); &#125; else &#123; mapT.put(t.charAt(i), 1); &#125; &#125; if (mapS.equals(mapT)) &#123; return true; &#125; return false; &#125; 方法二：public boolean isAnagram(String s, String t) &#123; if (s == null &amp;&amp; t == null) &#123; return true; &#125; if (s == null || t == null) &#123; return false; &#125; if(s.length() != t.length())&#123; return false; &#125; char[] ss = s.toCharArray(); char[] tt = t.toCharArray(); Arrays.sort(ss); Arrays.sort(tt); return Arrays.equals(ss,tt); &#125; 思路：12方法一使用map方法二使用Arrays类的特性]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[387 字符串中的第一个唯一字符]]></title>
    <url>%2F2019%2F03%2F04%2F387%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。说明：1您可以假定该字符串只包含小写字母。 示例：12345s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2. 代码实现：123456789101112131415161718192021222324252627282930313233方法1：public int firstUniqChar(String s) &#123; int res = -1; LinkedHashMap&lt;Character, Integer&gt; map = new LinkedHashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; if (map.containsKey(s.charAt(i))) &#123; map.put(s.charAt(i), map.get(s.charAt(i)) + 1); &#125; else &#123; map.put(s.charAt(i), 1); &#125; &#125; for (int i = 0; i &lt; s.length(); i++) &#123; if (map.get(s.charAt(i)) == 1) &#123; res = i; break; &#125; &#125; return res; &#125; 方法2：public int firstUniqChar(String s) &#123; int res = -1; for (char ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ch++) &#123; int index = s.indexOf(ch); if (index != -1 &amp;&amp; index == s.lastIndexOf(ch)) &#123; res = (res == -1 || res &gt; index) ? index : res; &#125; &#125; return res; &#125; 思路：12方法1利用LinkedHashMap的有序性方法2利用String的indexOf()和lastIndexOf()方法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[344 反转字符串]]></title>
    <url>%2F2019%2F02%2F10%2F344%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例1：12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例2：12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 代码实现：1234567891011121314public void reverseString(char[] s) &#123; if (s.length == 0) &#123; return; &#125; int i = 0, j = s.length - 1; while (i &lt; s.length / 2) &#123; char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; &#125; &#125; 思路：1首位互换，以temp作为中间值]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[139 单词拆分]]></title>
    <url>%2F2019%2F02%2F09%2F139%20%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。说明：12拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。 示例1：123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例2：1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例3：12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 代码实现：1234567891011121314151617public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; if(s.isEmpty() || wordDict.isEmpty())&#123; return false; &#125; boolean[] mark = new boolean[s.length() + 1]; mark[0] = true; for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if(mark[j] &amp;&amp; wordDict.contains(s.substring(j,i)))&#123; mark[i] = true; break; &#125; &#125; &#125; return mark[s.length()]; &#125; 思路：1234动态规划将一个字符串拆成两部分，若前半部分是可分的，后半部分存在于dict中，则整个字符串成立例如leetcode，若leet是可拆分的，code在dict中，则leetcode是可拆分的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[131 分割回文串]]></title>
    <url>%2F2019%2F02%2F08%2F131%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。示例：123456输入: &quot;aab&quot;输出:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 代码实现：12345678910111213141516171819202122232425262728293031323334class Solution &#123; List&lt;List&lt;String&gt;&gt; results = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; if (s.isEmpty()) &#123; return results; &#125; find(s, 0, new ArrayList&lt;&gt;()); return results; &#125; private void find(String s, int index, List&lt;String&gt; list) &#123; if (index == s.length()) &#123; results.add(new ArrayList&lt;&gt;(list)); return; &#125; for (int i = index; i &lt; s.length(); i++) &#123; if (isPalindrome(s, index, i)) &#123; list.add(s.substring(index, i + 1)); find(s, i + 1, list); list.remove(list.size() - 1); &#125; &#125; &#125; private boolean isPalindrome(String s, int begin, int end) &#123; while (begin &lt; end &amp;&amp; s.charAt(begin) == s.charAt(end)) &#123; begin++; end--; &#125; return begin &gt;= end; &#125;&#125; 思路：1234567深搜先深搜到层3，将 s 分割为 “a”,”a”,”b”，并记录此分割方案 [“a”,”a”,”b”]回溯到层2， “a” 不动，判断 “ab” 不满足（即考虑 [“a”,”ab”] 方案）回溯到层1，判断”aa” 满足进入层2，判断 “b” 满足，此时记录此种方案 [“aa”,”b”]回溯到层1，”aa”的基础上加上 “b”，判断 “aab” 不满足层1 遍历结束，整个流程结束。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[125 验证回文串]]></title>
    <url>%2F2019%2F02%2F07%2F125%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：1本题中，我们将空字符串定义为有效的回文串 示例1：12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例2：12输入: &quot;race a car&quot;输出: false 代码实现：1234567891011121314151617181920212223public boolean isPalindrome(String s) &#123; if (s == null || s.length() == 0) &#123; return true; &#125; StringBuilder sb = new StringBuilder(); char[] chars = s.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; if ((chars[i] &gt;= &apos;a&apos; &amp;&amp; chars[i] &lt;= &apos;z&apos;) || (chars[i] &gt;= &apos;A&apos; &amp;&amp; chars[i] &lt;= &apos;Z&apos;) || (chars[i] &gt;= &apos;0&apos; &amp;&amp; chars[i] &lt;= &apos;9&apos;)) &#123; sb.append(chars[i]); &#125; &#125; chars = sb.toString().toCharArray(); for (int i = 0, j = chars.length - 1; i &lt;= chars.length / 2 - 1; i++, j--) &#123; if (Character.toUpperCase(chars[i]) != Character.toUpperCase(chars[j])) &#123; return false; &#125; &#125; return true; &#125; 思路：1从数组两端同时开始遍历，比较是否相等]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[887 鸡蛋掉落]]></title>
    <url>%2F2019%2F02%2F06%2F887%20%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD%2F</url>
    <content type="text"><![CDATA[你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。 你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。 你的目标是确切地知道 F 的值是多少。 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ 示例1：1234567输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。 示例2：12输入：K = 2, N = 6输出：3 示例3：12输入：K = 3, N = 14输出：4 提示：121 &lt;= K &lt;= 1001 &lt;= N &lt;= 10000 代码实现：12345678910111213141516171819202122232425262728public int superEggDrop(int K, int N) &#123; int[][] records = new int[K + 1][N + 1]; for (int i = 0; i &lt;= K; i++) &#123; records[i][0] = 0; records[i][1] = 1; &#125; for (int i = 0; i &lt;= N; i++) &#123; records[1][i] = i; &#125; for (int i = 2; i &lt;= K; i++) &#123; for (int j = 2; j &lt;= N; j++) &#123; records[i][j] = Integer.MAX_VALUE; for (int index = 1; index &lt;= j; index++) &#123; int res = Math.max(records[i - 1][index - 1], records[i][j - index]) + 1; if (res &lt; records[i][j]) &#123; records[i][j] = res; &#125; &#125; &#125; &#125; return records[K][N]; &#125; 思路：123456789动态规划当只有0层楼高时，dp[i][0] == 0当只有1层楼高时，dp[i][1] == 1当只有1个鸡蛋时，dp[1][i] == i若第一次从第x层开始尝试dp[k-1][x-1]为第一次尝试后鸡蛋摔碎的情况dp[k][n-x]为第一次尝试后鸡蛋没有摔碎的情况则 dp[k][n] = Math.max(dp[k-1][x-1],dp[k][n-x]) + 1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[88 合并两个有序数组]]></title>
    <url>%2F2019%2F02%2F05%2F88%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。说明：12初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例：12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 代码实现：1234567891011121314151617181920public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int length = m + n - 1; m--; n--; while (m &gt;= 0 &amp;&amp; n &gt;= 0) &#123; if (nums2[n] &gt; nums1[m]) &#123; nums1[length] = nums2[n]; n--; &#125; else &#123; nums1[length] = nums1[m]; m--; &#125; length--; &#125; while (n &gt;= 0) &#123; nums1[length] = nums2[n]; n--; length--; &#125; &#125; 思路：123合并后nums1数组的大小为m+n，则从后往前赋值，比较nums1和nums2末尾元素的大小，将大的赋值给nums1。当有数组的个数为0时，再查看nums2数组元素个数，如果有剩余，则赋值到nums1剩余部分。nums1不需查看，因为如果nums1有剩余，他的顺序是不需要改变的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[240 搜索二维矩阵II]]></title>
    <url>%2F2019%2F02%2F04%2F240%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II%2F</url>
    <content type="text"><![CDATA[m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：每行的元素从左到右升序排列。每列的元素从上到下升序排列。示例：12345678910111213现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。 代码实现：1234567891011121314151617public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int j = matrix[0].length - 1; int i = 0; while (i &lt; matrix.length &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] == target) &#123; return true; &#125; else if (matrix[i][j] &gt; target) &#123; j--; &#125; else &#123; i++; &#125; &#125; return false; &#125; 思路：1将target与每行的最后一个值比较，若target大于最后一个值，则target在改行下面，直到target小于等于最后一个值，此时target要么在该行，要么不存在]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[169 求众数]]></title>
    <url>%2F2019%2F02%2F02%2F169%20%E6%B1%82%E4%BC%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。123说明：你可以假设数组是非空的，并且给定的数组总是存在众数。 示例1：12输入: [3,2,3]输出: 3 示例2：12输入: [2,2,1,1,1,2,2]输出: 2 代码实现：123456789101112131415161718public int majorityElement(int[] nums) &#123; int count = 0; int res = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (count == 0) &#123; res = nums[i]; count++; &#125; else &#123; if (nums[i] == res) &#123; count++; &#125; else &#123; count--; &#125; &#125; &#125; return res; &#125; 思路：1众数的个数超过总个数的一半，因此，每次遇到不相同的数字，则相互抵消，遍历整个数组后，最后剩下的，一定是众数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[136 只出现一次的数字]]></title>
    <url>%2F2019%2F02%2F01%2F136%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。123说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例1：12输入: [2,2,1]输出: 1 示例2：12输入: [4,1,2,1,2]输出: 4 代码实现：12345678910public int singleNumber(int[] nums) &#123; if (nums.length == 0) &#123; return -1; &#125; int single = 0; for (int i = 0; i &lt; nums.length; i++) &#123; single ^= nums[i]; &#125; return single; &#125; 思路：123异或运算(^) 参与运算的两个对象，相应位相同为0，不同为1数组依次做异或运算，相同值抵消，便得到最终结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类型转换与集合转换]]></title>
    <url>%2F2019%2F01%2F03%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E9%9B%86%E5%90%88%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[类型转换parseInt()、valueOf()、toString()和intValue()的区别与联系 parseXxx():将String转换为对应xxx的普通数据类型String s = “123”;int b = Integer.parseInt(a);b就是int类型123了byte c = Byte.parseByte(a);c就是byte类型123了 valueOf():将参数转换为对应的包装类型String a = “123”;Integer b = Integer.valueOf(a);此时b为Integer类型 intValue():将Integer类型转换为int类型Integer a = 1;int b = a.intValue(a);此时b为int类型 toString():将引用数据类型转换为String字符串类型Integer a = new Integer(123);String b = a.toString();此时b为“123” 基本类型的数组转换为包装类型的数组 12345678910111213// java8实现方法int[] arr = &#123;&#125;;List&lt;Integer&gt; list = Arrays.stream(arr).boxed().collect(Collectors.toList());// apache commons-lang3 jar// maven&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt;&lt;/dependency&gt;Integer[] list = ArrayUtils.toObject(arr); 集合转换 数组转list1234567// 要求要转换的数组必须类型一致Integer[] arr = &#123;&#125;;// 第一种List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(arr));// 第二种List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.addAll(Arrays.asList(arr)); 12345// 相对于上一种方法速度更快// 要求要转化的数组必须类型一致Integer[] arr = &#123;&#125;;List&lt;Integer&gt; list = new ArrayList&lt;&gt;();Collections.addAll(list,arr); list转数组123// 只能得到对应包装类型的数组List&lt;Integer&gt; list = new ArrayList&lt;&gt;();Integer[] arr = list.toArray(new Integer[list.size]);]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令整理]]></title>
    <url>%2F2018%2F12%2F12%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[用户操作 新建用户(以下命令必须在root权限下使用)123456// 新建用户后,用户信息会保存在/home和/etc/passwd下useradd visitor // 新建用户，用户名为visitorpasswd visitor // 为新建用户设置密码userdel visitor // 删除用户visitorrm -rf visitor // 删除用户visitor所在目录 新建用户组 1234groupadd visitgroup // 添加用户组groupdel visitgroup // 删除用户组gpasswd -a visitor visitgroup // 把用户visitor添加到visitgroup组中(加入组后,visitor获得visitgroup组所有权限)gpasswd -d visitor visitgroup // 把用户visitor移出visitgroup组 切换用户 1su // su是switch user的缩写,exit即退回到刚才的用户状态 切换目录 12345cd xx // 切换到该目录下的xx目录cd .. // 切换到上一层目录cd / // 切换到系统根目录cd ~ // 切换到用户主目录cd - // 切换到上一个所在目录 目录操作(增删查改) 1234567mkdir xx // 增加名为xx的目录ls或者ll // 查看目录详细信息find /home -name &quot;*.txt&quot; // 查找/home目录下以.txt结尾的文件。(-iname忽略大小写)mv 目录名称 新目录名称 // 修改目录的名称mv 目录名称 目录的新位置 // 移动目录的位置cp -r 目录名称 目录拷贝的目标位置 // 拷贝目录rm -rf 目录/文件/压缩包 // 删除操作 文件操作(增删查改) 123456789101112touch 文件名称 // 文件的创建cat/more/less/tail 文件名称 // 文件的查看 cat:只能显示最后一屏内容 more:显示百分比，回车向下一行,空格向下一页，q退出查看 less:使用键盘上的PgUp和PgDn向上向下翻页，q结束查看 tail-10:查看文件的后10行，Ctrl+C结束(注)tail -f 文件 // 可以对某个文件进行动态监控vim 文件 // 修改文件的内容 i // 进入编辑模式 Esc // 进入底行模式,输入:wq/q! (输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存) 输入./进入文件搜索，输入要搜索的单词，回车，即可跳转到该单词所在的位置。rm -rf 文件 // 删除文件 压缩操作 1234567tar -zcvf 打包压缩后的文件名 要打包压缩的文件 // 打包并压缩文件,压缩后的文件以 .tar.gz结尾 z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名tar -xvf 压缩文件 // 解压压缩包 x：代表解压 其他操作 1234567891011pwd // 显示当前所在位置grep 要搜索的字符串 要搜索的文件 --color // 搜索命令，--color代表高亮显示shutdown -r now // 立即重启服务器wc // 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 命令格式：wc [选项]文件... 命令参数： -c 统计字节数。 -l 统计行数。 -m 统计字符数。这个标志不能与 -c标志一起使用。 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。 -L 打印最长行的长度]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收机制详解]]></title>
    <url>%2F2018%2F12%2F08%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[垃圾收集概念GC需要做三件事： 分配内存，为每个新建的对象分配空间 确保还在使用的对象的内存一直都在，不能把有用的空间当垃圾回收了 释放不再使用的对象所占用的内存 GC Roots把还被GC Roots引用的对象称为活的，把不再被引用的对象认为死的。 GC Roots有： 当前各线程执行方法中的局部变量(包括形参)引用的对象 已被加载的类的static域引用的对象 方法去中常量引用的对象 JNI(Java Native Interface)引用 性能指标 吞吐量：应用程序的执行时间占总时间的百分比，越高越好 垃圾收集开销：垃圾收集时间占总时间的百分比 停顿时间：垃圾收集过程中导致的应用挂起时间 频次：相对于应用程序来说，垃圾收集的频次 空间：垃圾收集占用的内存 及时性：一个对象从成为垃圾到该对象空间再次可用的时间 垃圾回收类型内存被组织分成三个年代：年轻代、老年代、永久代；大部分对象初始化都是在年轻代中，老年代存放经过几次年轻代垃圾收集还活着的对象，还有部分大对象因为比较大所以直接分配在老年代，永久代通常也叫方法区，用于存储已加载类的元数据，以及存储运行时常量池等。 当年轻代被填满后，会进行一次年轻代垃圾收集(minor GC) 当老年代或永久代被填满了，会触发full GC(major GC)，full GC 会收集所有区域，先进行年轻代的收集，使用年轻代专用的垃圾回收算法，然后使用老年代的垃圾回收算法回收老年代和永久代。如果算法带有压缩，每个代分别独立的进行压缩。 分配内存 如果垃圾收集完成后，存在大片连续的内存可用于分配给新对象，此时使用指针碰撞分配对象空间(检测是否有足够的空间，如果有，指针往前移动你N位就分配好空间了) 对于多线程应用，对象分配必须要保证线程安全性，如果使用全局锁，那么分配空间将成为瓶颈并降低程序性能。HotSpot使用TLABs，给与每个线程一部分内存作为缓冲区，每个线程都在自己的缓存区种进行指针碰撞，这样就不用获取全局锁了。 串行收集器串行收集器，年轻代和老年代都使用单线程进行收集，收集过程中会 stop-the-world。所以当在垃圾收集的时候，应用程序是完全停止的。在年轻代和老年代中都使用串行收集器，年轻代中使用 stop-the-world、复制 算法；老年代使用 stop-the-world、标记 -&gt; 清理 -&gt; 压缩 算法 并行收集器并行收集器，即吞吐量收集器，利用多核的优势来进行垃圾收集，而不是像串行收集器一样将程序挂起后只使用单线程来收集垃圾。在年轻代中使用 并行、stop-the-world、复制 算法；老年代使用串行收集器的 串行、stop-the-world、标记 -&gt; 清理 -&gt; 压缩 算法 并行压缩收集器在年轻代中使用并行收集器的 并行、stop-the-world、复制 算法；老年代使用 并行、stop-the-world、标记 -&gt; 清理 -&gt; 压缩 算法。和并行收集器的区别是老年代使用了并行 CMS收集器(低延时收集器) 在年轻代中，CMS和并行收集器一样，即：并行、stop-the-world、复制 在老年代中，大部分收集任务是和应用程序并发执行的 CMS 收集过程首先是一段小停顿 stop-the-world，叫做 初始标记阶段（initial mark），用于确定 GC Roots。然后是 并发标记阶段（concurrent mark），标记 GC Roots 可达的所有存活对象，由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。为了解决这个问题，需要再次停顿应用程序，称为 再次标记阶段（remark），遍历在并发标记阶段应用程序修改的对象（标记出应用程序在这个期间的活对象），由于这次停顿比初始标记要长得多，所以会使用多线程并行执行来增加效率。再次标记阶段结束后，能保证所有存活对象都被标记完成，所以接下来的 并发清理阶段（concurrent sweep） 将就地回收垃圾对象所占空间。 CMS是唯一不进行压缩的收集器，在它释放了垃圾对象占用的空间后，不会移动存活对象到一边去。着将节省垃圾回收的时间。 缺点 由于之后空闲空间不是连续的，所以也就不能使用简单的 指针碰撞（bump-the-pointer） 进行对象空间分配了。它需要维护一个 空闲列表，将所有的空闲区域连接起来，当分配空间时，需要寻找到一个可以容纳该对象的区域。 CMS 收集器相比其他收集器需要使用更大的堆内存。因为在并发标记阶段，程序还需要执行，所以需要留足够的空间给应用程序。 虽然收集器能保证在标记阶段识别出所有的存活对象，但是由于应用程序并发运行，所以刚刚标记的存活对象很可能立马成为垃圾，而且这部分由于已经被标记为存活对象，所以只能到下次老年代收集才会被清理，这部分垃圾称为 浮动垃圾。 由于缺少压缩环节，堆将会出现碎片化问题。为了解决这个问题，CMS 收集器需要追踪统计最常用的对象大小，评估将来的分配需求，可能还需要分割或合并空闲区域。 G1垃圾收集器 G1的主要关注点在于达到可控的停顿时间，在这个基础上尽可能的提高吞吐量。 G1被设计用来长期取待CMS收集器，和CMS相同的地方在于，它们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。 当应用使用了较大的堆并且还要求有较低的垃圾收集停顿时间，选择G1。 内存划分G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的内存是连续的。和分代算法一样，G1 中每个块也会充当 Eden、Survivor、Old 三种角色，但是它们不是固定的，这使得内存使用更加地灵活。 收集流程G1收集器包含以下4各操作，年轻代收集、并发收集，和应用线程同时执行、混合式垃圾收集、必要时的 Full GC 年轻代收集(Young GC) G1收集器将堆内存分为大小固定的区块，整堆分为约2000块，每块大小是一致的 逻辑上，也会分为Eden、Survivor、Old区，但是各个区的大小不是固定的，未分配区可以用于任何一代 年轻代由几个不连续的区块组成，这样需要的时候可以很容易扩容、缩容 Young GC是并行、stop-the-world的 将活着的对象复制到Survivor区，或晋升到Old区 为了下一次Young GC，需要调整Eden区和Survivor区的大小 Old GC/并发标记周期 初始标记：stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用。 扫描根引用区：扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束。 并发标记：寻找整个堆的存活对象，该阶段可以被 Young GC 中断。 重新标记：stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法。 清理：清理阶段真正回收的内存很少。 混合垃圾回收周期 并发周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。 混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。 Full GC concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记。(这个时候说明堆需要增加了，或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束或者就是更早地进行并发周期，默认是整堆内存的 45% 被占用就开始进行并发周期) 晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败。(说明混合垃圾回收需要更迅速完成垃圾收集，也就是说在混合回收阶段，每次年轻代的收集应该处理更多的老年代已标记区块。) 疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的。(最简单的就是增加堆大小) 大对象分配失败:我们应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象。G1 参数配置和最佳实践 G1 调优的目标是尽量避免出现 Full GC，其实就是给老年代足够的空间，或相对更多的空间。有以下几点我们可以进行调整的方向： 增加堆大小，或调整老年代和年轻代的比例，这个很好理解 增加并发周期的线程数量，其实就是为了加快并发周期快点结束 让并发周期尽早开始，这个是通过设置堆使用占比来调整的（默认 45%） 在混合垃圾回收周期中回收更多的老年代区块 G1对比CMS优点 G1是一个有整理内存过程的垃圾收集器，不会产生过多内存碎片。CMS采用标记清除垃圾回收算法，可能会产生不少内存碎片。 G1的 Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。 共同点 他们都属于并发收集器，在大部分的收集阶段都不需要挂起应用程序。]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用操作及常见问题解决]]></title>
    <url>%2F2018%2F12%2F07%2FGit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[与远程仓库建立连接 在远程仓库新建一个项目 生成本地的git管理,在terminal或git里输入 git init 将项目中所有文件添加到仓库中 git add . 添加对本次提交的注释 git commit -m “” (双引号内为对于本次提交的注释内容) 将本地的仓库关联到远程仓库 git remote add origin https://github.com/ZS-Oliver/go.git 将代码上传到远程仓库 git push -u origin master(-u操作,Git不但会把本地的master分支内容推送到远程新的master分支,还会把本地的master分支和远程的master分支关联起来,在以后的推送或者拉取时就可以简化命令) 分支问题 查看分支信息 1git branch 在本地新建一个分支 1git branch newBranchName 切换分支 1git checkout branch 在本地创建并切换到新分支 1git checkout -b newBranchName 将新分支发布到远程仓库 1git push origin newBranchName 在本地删除一个分支 1git branch -d newBranchName 删除远程仓库的一个分支 1git push origin :newBranchName/git push origin -delete newBranchName // 删除远程分支后,对应的本地分支并不会同步删除 合并指定分支到当前分支 1git merge branchName stash 把本地修改且未提交的内容,存储到本地栈的栈顶 1git stash 把保存在本地栈的代码pop到本地 1git stash pop stash的同时,存储一个log日志 1git stash save &quot;&quot; //双引号为日志内容 查看本地存储的stash日志 1git stash list stash多个日志时,有选择的pop 1git stash apply stash@&#123;&#125; //@&#123;&#125;为对应日志序号 清空暂存栈 1git stash clear 回退 撤销一次提交 1git revert 回退到上一个版本 12git reset --hard HEAD^ // 回退到上一版本，(Git中, **HEAD** 表示当前版本,也就是最新的提交,HEAD^ 为上一个版本,HEAD^^为上上个版本,也可以用**HEAD~3**表示)git reset --hard 版本号 // 回退到指定版本(版本号只需要写前几位) 将暂存区的修改撤销掉,重新放回工作区 1git reset HEAD &lt;file&gt; // 使用git rm删除文件后,复原操作,需要先git reset HEAD &lt;file&gt;,然后再git checkout -- &lt;file&gt; 将工作区的修改全部撤销 1git checkout -- file // file为要撤销的文件 撤销上一次的合并分支 1git merge --abort 其他 查看日志 1git log 查看暂存区状态 1git status 查看之前的所有命令日志 1git reflog 删除文件 12rm file // 删除本地文件git rm file // 从版本库中删除文件 问题原因及解决方法 问题: Another git process semms to be running in this repository, e.g. an editor opened by ‘git commit’. Please make sure all processes are terminated then try again. If it still fails, a git process remove the file manually to continue… 原因: git被另外一个程序占用，重启机器也不能够解决。Git在使用过程中遭遇了奔溃，部分被上锁资源没有被释放导致的。 解决方法: 进入项目文件夹下的 .git文件中（显示隐藏文件夹或rm .git/index.lock）删除index.lock文件即可。 问题: There is no tracking information for the current branch.Please specify which branch you want to merge with. 原因: 本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系) 解决方法: 1git branch --set-upstream-to=origin/远程分支的名字 本地分支的名字 问题: 使用git pull提示refusing to merge unrelated histories 原因: 远程仓库origin上的分支master和本地分支master被Git认为是不同的仓库，所以不能直接合并。 解决方法:12git pull --allow-unrelated-histories解决冲突后再执行 git push 问题: hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. ‘git pull’)hint: before pushing again.hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details. 原因: 远程repository和本地的repository冲突 解决方法: 新建分支,切换到新分支,pull,然后切换到主分支,合并分支,解决冲突 问题：fatal:remote origin already exists 解决方法：1234删除远程Git仓库git remote rm origin添加远程Git仓库git remote add origin...]]></content>
      <categories>
        <category>技术文档</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
